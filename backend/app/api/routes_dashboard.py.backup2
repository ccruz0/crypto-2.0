"""Dashboard API endpoints
Provides unified dashboard state endpoint for frontend
"""
import time
import logging
from datetime import datetime, timedelta, timezone
from typing import Dict, List, Optional, Tuple, Any

from fastapi import APIRouter, Depends, HTTPException, Body
from sqlalchemy import and_, or_, text, func
from sqlalchemy.orm import Session

from app.database import get_db
from app.deps.auth import get_current_user
from app.models.exchange_balance import ExchangeBalance
from app.models.exchange_order import ExchangeOrder, OrderStatusEnum, OrderSideEnum
from app.models.trade_signal import PresetEnum, RiskProfileEnum, SignalStatusEnum, TradeSignal
from app.models.watchlist import WatchlistItem
from app.services.brokers.crypto_com_trade import trade_client
from app.services.exchange_sync import exchange_sync_service
from app.services.portfolio_cache import get_portfolio_summary
    # üî• TEMP DISABLED: # NOTE: update_portfolio_cache is NOT imported - this endpoint ONLY reads from cache
    # üî• TEMP DISABLED: # Background service (exchange_sync) updates the cache automatically

router = APIRouter()
log = logging.getLogger("app.dashboard")


@router.get("/dashboard")
def get_dashboard(db: Session = Depends(get_db)):
    # No auth required - this endpoint is public for dashboard data
    """Get all watchlist items with complete data - OPTIMIZED FAST VERSION"""
    import time as time_module
    start_time = time_module.time()
    
    if db is None:
        log.error("Database session is None - database not available")
        return []
    
    try:
        # Use timeout for database query to prevent hanging
        # Get watchlist items with explicit timeout
        items = []
        try:
            # Execute query and immediately convert to list to avoid lazy loading issues
            # Use explicit session management to prevent hanging
            items = list(db.query(WatchlistItem).limit(100).all())
            # Immediately close the query result to free resources
            query_time = time_module.time() - start_time
            log.info(f"Query completed in {query_time:.3f}s, returning {len(items)} watchlist items")
        except Exception as query_err:
            log.error(f"Database query error: {query_err}", exc_info=True)
            if db:
                try:
                    db.rollback()  # Rollback on error
                except:
                    pass
            return []
        
        # Build result quickly - avoid any operations that can hang
        result = []
        for item in items:
            try:
                result.append({
                    "id": item.id,
                    "symbol": item.symbol,
                    "exchange": item.exchange,
                    "alert_enabled": item.alert_enabled,
                    "trade_enabled": item.trade_enabled,
                    "trade_amount_usd": item.trade_amount_usd,
                    "trade_on_margin": item.trade_on_margin,
                    "sl_tp_mode": item.sl_tp_mode,
                    "sl_percentage": item.sl_percentage,
                    "tp_percentage": item.tp_percentage,
                    "sl_price": item.sl_price,
                    "tp_price": item.tp_price,
                    "buy_target": item.buy_target,
                    "take_profit": item.take_profit,
                    "stop_loss": item.stop_loss,
                    # Market data from watchlist (frontend will merge with top-coins-data)
                    "price": item.price,
                    "rsi": item.rsi,
                    "atr": item.atr,
                    "ma50": item.ma50,
                    "ma200": item.ma200,
                    "ema10": item.ema10,
                    "res_up": item.res_up,
                    "res_down": item.res_down,
                    # Order data
                    "order_status": item.order_status,
                    "order_date": item.order_date.isoformat() if item.order_date else None,
                    "purchase_price": item.purchase_price,
                    "quantity": item.quantity,
                    "sold": item.sold,
                    "sell_price": item.sell_price,
                    "notes": item.notes,
                    "created_at": item.created_at.isoformat() if item.created_at else None,
                    "signals": item.signals,
                    "skip_sl_tp_reminder": item.skip_sl_tp_reminder
                })
            except Exception as item_err:
                log.warning(f"Error processing item {item.id}: {item_err}")
                continue
        
        total_time = time_module.time() - start_time
        log.info(f"Dashboard endpoint completed in {total_time:.3f}s, returning {len(result)} items")
        
        if total_time > 1.0:
            log.warning(f"‚ö†Ô∏è Dashboard endpoint took {total_time:.3f}s - this is slow! Should be < 0.5 seconds.")
        
        return result
    except Exception as e:
        log.error(f"Error in dashboard endpoint: {e}", exc_info=True)
        if db:
            try:
                db.rollback()
            except:
                pass
        return []


@router.post("/dashboard")
def add_to_dashboard(
    item: dict = Body(...),
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """Add new watchlist item"""
    try:
        symbol = item.get("symbol", "").upper()
        if not symbol:
            raise HTTPException(status_code=400, detail="symbol is required")
        
        # Log what we're receiving for debugging
        log.info(f"Creating/updating watchlist item for {symbol} with data: {item}")
        
        # Check if item already exists - if it does, update it instead of creating new
        existing = db.query(WatchlistItem).filter(WatchlistItem.symbol == symbol).first()
        if existing:
            # Update existing item instead of raising error
            log.info(f"Watchlist item for {symbol} already exists (ID={existing.id}), updating it")
            watchlist_item = existing
            # Update all provided fields
            if "alert_enabled" in item:
                watchlist_item.alert_enabled = item["alert_enabled"]
            if "trade_enabled" in item:
                old_value = watchlist_item.trade_enabled
                watchlist_item.trade_enabled = item["trade_enabled"]
                log.info(f"Updated trade_enabled for {symbol}: {old_value} -> {watchlist_item.trade_enabled}")
            if "trade_amount_usd" in item:
                watchlist_item.trade_amount_usd = item["trade_amount_usd"]
            if "trade_on_margin" in item:
                watchlist_item.trade_on_margin = item["trade_on_margin"]
            if "sl_tp_mode" in item:
                watchlist_item.sl_tp_mode = item["sl_tp_mode"]
            if "sl_percentage" in item:
                watchlist_item.sl_percentage = item["sl_percentage"]
            if "tp_percentage" in item:
                watchlist_item.tp_percentage = item["tp_percentage"]
            if "sl_price" in item:
                watchlist_item.sl_price = item["sl_price"]
            if "tp_price" in item:
                watchlist_item.tp_price = item["tp_price"]
            if "buy_target" in item:
                watchlist_item.buy_target = item["buy_target"]
            if "take_profit" in item:
                watchlist_item.take_profit = item["take_profit"]
            if "stop_loss" in item:
                watchlist_item.stop_loss = item["stop_loss"]
            db.commit()
            db.refresh(watchlist_item)
        else:
            # Create new watchlist item
            watchlist_item = WatchlistItem(
                symbol=symbol,
                exchange=item.get("exchange", "CRYPTO_COM"),
                alert_enabled=item.get("alert_enabled", False),
                trade_enabled=item.get("trade_enabled", False),
                trade_amount_usd=item.get("trade_amount_usd"),
                trade_on_margin=item.get("trade_on_margin", False),
                sl_tp_mode=item.get("sl_tp_mode", "conservative"),
                sl_percentage=item.get("sl_percentage"),
                tp_percentage=item.get("tp_percentage"),
                sl_price=item.get("sl_price"),
                tp_price=item.get("tp_price"),
                buy_target=item.get("buy_target"),
                take_profit=item.get("take_profit"),
                stop_loss=item.get("stop_loss")
            )
            
            db.add(watchlist_item)
            db.commit()
            db.refresh(watchlist_item)
        
        log.info(f"Created/Updated watchlist item for {symbol}: trade_enabled={watchlist_item.trade_enabled}, trade_amount_usd={watchlist_item.trade_amount_usd}")
        
        return {
            "id": watchlist_item.id,
            "symbol": watchlist_item.symbol,
            "exchange": watchlist_item.exchange,
            "alert_enabled": watchlist_item.alert_enabled,
            "trade_enabled": watchlist_item.trade_enabled,
            "trade_amount_usd": watchlist_item.trade_amount_usd,
            "trade_on_margin": watchlist_item.trade_on_margin,
            "sl_price": watchlist_item.sl_price,
            "tp_price": watchlist_item.tp_price
        }
    except HTTPException:
        raise
    except Exception as e:
        log.error(f"Error creating watchlist item: {e}", exc_info=True)
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/dashboard/{item_id}")
def update_dashboard_item(
    item_id: int,
    item: dict = Body(...),
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """Update watchlist item"""
    try:
        watchlist_item = db.query(WatchlistItem).filter(WatchlistItem.id == item_id).first()
        
        if not watchlist_item:
            raise HTTPException(status_code=404, detail=f"Watchlist item {item_id} not found")
        
        # Log what we're receiving for debugging
        log.info(f"Updating watchlist item {item_id} ({watchlist_item.symbol}) with data: {item}")
        log.info(f"Current state before update: trade_enabled={watchlist_item.trade_enabled}, trade_amount_usd={watchlist_item.trade_amount_usd}")
        
        # Update all provided fields
        if "symbol" in item:
            watchlist_item.symbol = item["symbol"].upper()
        if "exchange" in item:
            watchlist_item.exchange = item["exchange"]
        if "alert_enabled" in item:
            watchlist_item.alert_enabled = item["alert_enabled"]
        if "trade_enabled" in item:
            old_value = watchlist_item.trade_enabled
            new_value = item["trade_enabled"]
            log.info(f"üîµ Received trade_enabled in request: {new_value} (type: {type(new_value).__name__})")
            watchlist_item.trade_enabled = new_value
            log.info(f"‚úÖ Updated trade_enabled for {watchlist_item.symbol}: {old_value} -> {watchlist_item.trade_enabled}")
        else:
            log.warning(f"‚ö†Ô∏è trade_enabled NOT in request data for {watchlist_item.symbol}. Keys in request: {list(item.keys())}")
        if "trade_amount_usd" in item:
            watchlist_item.trade_amount_usd = item["trade_amount_usd"]
        if "trade_on_margin" in item:
            watchlist_item.trade_on_margin = item["trade_on_margin"]
        if "sl_tp_mode" in item:
            watchlist_item.sl_tp_mode = item["sl_tp_mode"]
        if "sl_percentage" in item:
            watchlist_item.sl_percentage = item["sl_percentage"]
        if "tp_percentage" in item:
            watchlist_item.tp_percentage = item["tp_percentage"]
        if "sl_price" in item:
            watchlist_item.sl_price = item["sl_price"]
        if "tp_price" in item:
            watchlist_item.tp_price = item["tp_price"]
        if "buy_target" in item:
            watchlist_item.buy_target = item["buy_target"]
        if "take_profit" in item:
            watchlist_item.take_profit = item["take_profit"]
        if "stop_loss" in item:
            watchlist_item.stop_loss = item["stop_loss"]
        
        db.commit()
        db.refresh(watchlist_item)
        
        log.info(f"Updated watchlist item {item_id} ({watchlist_item.symbol}): trade_enabled={watchlist_item.trade_enabled}, trade_amount_usd={watchlist_item.trade_amount_usd}")
        
        return {
            "id": watchlist_item.id,
            "symbol": watchlist_item.symbol,
            "exchange": watchlist_item.exchange,
            "alert_enabled": watchlist_item.alert_enabled,
            "trade_enabled": watchlist_item.trade_enabled,
            "trade_amount_usd": watchlist_item.trade_amount_usd,
            "trade_on_margin": watchlist_item.trade_on_margin,
            "sl_price": watchlist_item.sl_price,
            "tp_price": watchlist_item.tp_price
        }
    except HTTPException:
        raise
    except Exception as e:
        log.error(f"Error updating watchlist item {item_id}: {e}", exc_info=True)
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/dashboard/{item_id}")
def delete_dashboard_item(
    item_id: int,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """Delete watchlist item"""
    try:
        watchlist_item = db.query(WatchlistItem).filter(WatchlistItem.id == item_id).first()
        
        if not watchlist_item:
            raise HTTPException(status_code=404, detail=f"Watchlist item {item_id} not found")
        
        symbol = watchlist_item.symbol
        db.delete(watchlist_item)
        db.commit()
        
        log.info(f"Deleted watchlist item {item_id} ({symbol})")
        
        return {"ok": True, "message": f"Deleted watchlist item for {symbol}"}
    except HTTPException:
        raise
    except Exception as e:
        log.error(f"Error deleting watchlist item {item_id}: {e}", exc_info=True)
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))


def timed(label: str, func, *args, **kwargs) -> Tuple[Any, Optional[Exception]]:
    """
    Wrapper to time a function call and log duration.
    Returns (result, error) tuple. error is None if successful.
    """
    t0 = time.perf_counter()
    try:
        res = func(*args, **kwargs)
        elapsed_ms = (time.perf_counter() - t0) * 1000
        log.info("dashboard.%s.ms=%.1f", label, elapsed_ms)
        return res, None
    except Exception as e:
        elapsed_ms = (time.perf_counter() - t0) * 1000
        log.error("dashboard.%s.error=%s ms=%.1f", label, repr(e), elapsed_ms, exc_info=True)
        return None, e


@router.get("/dashboard/state")
def get_dashboard_state(db: Session = Depends(get_db)):
    """
    Get complete dashboard state in a single response - optimized for speed
    
    TEMPORARY: Ultra-simplified version that returns empty data immediately
    TODO: Fix database connection/query performance issues
    """
    import time as time_module
    start_time = time_module.time()
    
    log.info("Starting dashboard state fetch (ultra-simplified version)")
    
    # Return minimal response IMMEDIATELY without any database operations
    # This prevents timeout while we investigate database connection issues
    try:
        # Skip ALL database operations - return empty response immediately
        log.warning("Returning empty dashboard state to prevent timeout")
        
        # TEMPORARILY DISABLED: All service checks to prevent timeout
        # These checks may be blocking - return default values
        bot_is_running = True  # Assume running to avoid blocking checks
        bot_status = "running"
        bot_reason = None
        log.debug("Service checks disabled to prevent timeout")
        
        # Fetch balances from cached portfolio data (backend-maintained cache)
        # Frontend only reads from this cache - no external API calls
        balance_data = []
        total_usd_value = 0.0
        portfolio_last_updated_iso = None
        portfolio_summary = {}
        PORTFOLIO_STALENESS_SECONDS = 60
        
        # TEMPORARILY DISABLED: get_portfolio_summary is causing timeout
        # Return empty portfolio data - frontend can load portfolio from separate endpoint
        # TODO: Fix get_portfolio_summary performance or move to async/background task
        log.warning("Portfolio fetch disabled to prevent timeout - returning empty portfolio")
        portfolio_summary = {"balances": [], "total_usd": 0.0, "last_updated": None}
        total_usd_value = 0.0
        last_updated_ts = None
        portfolio_last_updated_iso = None
        error_labels.append("portfolio_disabled")
        partial_response = True
        
        # NEVER refresh cache on-demand - always use existing cache (even if stale)
    # üî• TEMP DISABLED:         # Background service (exchange_sync) updates cache every 5 seconds
        # This prevents timeout issues when external APIs (CoinGecko) are slow
        # Better to return stale data than timeout - frontend can show "last updated X minutes ago"
        if portfolio_summary.get("balances"):
            if last_updated_ts:
                age_seconds = time.time() - last_updated_ts
                if age_seconds > PORTFOLIO_STALENESS_SECONDS:
                    log.debug(f"Using stale portfolio cache ({age_seconds:.1f}s old) - background service should update it soon")
        else:
            # Cache is completely empty - this should only happen on first startup
            # Don't refresh here - it will timeout. Background service will populate it.
            log.warning("Portfolio cache is empty - background service will populate it. Returning empty balances for now.")
            portfolio_summary = {"balances": [], "total_usd": 0.0, "last_updated": None}
        
        # Use portfolio cache directly (no merge with ExchangeBalance needed)
        # Portfolio cache already has all balances with USD values calculated by backend
        # Frontend ONLY reads from this cache - no external API calls
        if portfolio_summary.get("balances"):
            log.debug(f"Using portfolio cache with {len(portfolio_summary['balances'])} balances, total_usd=${total_usd_value:,.2f}")
            
            # TEMPORARILY DISABLED: ExchangeBalance query to prevent timeout
            # This query can be slow and is not critical - we can use portfolio cache data directly
            exchange_balance_map = {}
            log.debug("ExchangeBalance query disabled to prevent timeout - using portfolio cache data directly")
            
            # Build balance data directly from portfolio cache (backend-maintained)
            for entry in portfolio_summary["balances"]:
                currency = (entry.get("currency") or "").upper()
                if not currency:
                    continue
                
                # Get balance amounts from cache (backend already calculated USD values)
                cache_balance = float(entry.get("balance", 0.0) or 0.0)
                usd_value = float(entry.get("usd_value", 0.0) or 0.0)
                
                # Log warning if USD value is missing from cache (shouldn't happen)
                if usd_value == 0.0 and cache_balance > 0 and currency not in ["USD", "USDT"]:
                    log.debug(f"USD value is 0 for {currency} with balance {cache_balance} (may not have price data)")
                
                # Use ExchangeBalance for free/locked breakdown if available, otherwise use cache balance
                if currency in exchange_balance_map:
                    free = exchange_balance_map[currency]["free"]
                    locked = exchange_balance_map[currency]["locked"]
                    total = exchange_balance_map[currency]["total"]
                else:
                    # Fallback to cache balance for all fields
                    free = cache_balance
                    locked = 0.0
                    total = cache_balance
                
                # Include all balances > 0 (even if USD value is 0 - backend will update it)
                if total > 0 or usd_value > 0:
                    balance_data.append({
                        "asset": currency,
                        "balance": total,
                        "free": free,
                        "locked": locked,
                        "total": total,
                        "usd_value": usd_value,  # From backend cache
                        "quantity": total,
                        "max_withdrawal": free,
                        "market_value": usd_value  # Same as usd_value
                    })
        else:
            log.warning("Portfolio cache has no balances - may need refresh")
        
        # Ensure total_usd_value is set correctly (use from cache or calculate from balances)
        if total_usd_value == 0.0 and balance_data:
            calculated_total = sum(item.get("usd_value", 0.0) for item in balance_data)
            if calculated_total > 0:
                log.info(f"Calculated total_usd_value from balances: ${calculated_total:,.2f}")
                total_usd_value = calculated_total
        
        # Log balance data summary for debugging
        balances_with_usd = [b for b in balance_data if b.get("usd_value", 0.0) > 0]
        log.info(f"Dashboard state: {len(balance_data)} balances total, {len(balances_with_usd)} with USD values, total_usd=${total_usd_value:,.2f}")
        if balances_with_usd:
            log.debug(f"Top 5 balances by USD value:")
            for b in sorted(balances_with_usd, key=lambda x: x.get("usd_value", 0.0), reverse=True)[:5]:
                log.debug(f"  {b.get('asset')}: ${b.get('usd_value', 0.0):,.2f} (balance: {b.get('balance', 0.0):.8f})")
        
        # TEMPORARILY DISABLED: Fast and slow signals queries are causing timeout
        # These queries are slow and not critical for dashboard loading
        # TODO: Optimize TradeSignal queries or move to separate endpoint
        fast_signals_data = []
        slow_signals_data = []
        log.debug("Signals queries disabled to prevent timeout - dashboard will load faster")
        
        # TEMPORARILY DISABLED: Open orders query to prevent timeout
        # TODO: Optimize ExchangeOrder query or move to separate endpoint
        open_orders_data = []
        log.debug("Open orders query disabled to prevent timeout - returning empty list")
        error_labels.append("open_orders_disabled")
        
        # Only call API if database is empty (DISABLED FOR NOW)
        if False and not open_orders_data:
            log.debug("Database empty, fetching open orders from Crypto.com API...")
            try:
                response = trade_client.get_open_orders()
                
                if response and "data" in response:
                    orders = response.get("data", [])
                    
                    for order in orders:
                        try:
                            # Extract order data from Crypto.com API format
                            order_id = order.get("order_id") or order.get("client_oid", "")
                            instrument_name = order.get("instrument_name", "")
                            order_type = order.get("order_type", "").upper()
                            side = order.get("side", "").upper()
                            status = order.get("status", "").upper()
                            
                            # Convert quantity and price
                            quantity = 0.0
                            price = 0.0
                            order_value = 0.0
                            avg_price = 0.0
                            cumulative_quantity = 0.0
                            cumulative_value = 0.0
                            
                            if order.get("quantity"):
                                quantity = float(order.get("quantity"))
                            if order.get("limit_price"):
                                price = float(order.get("limit_price"))
                            elif order.get("price"):
                                price = float(order.get("price"))
                            if order.get("order_value"):
                                order_value = float(order.get("order_value"))
                            if order.get("avg_price"):
                                avg_price = float(order.get("avg_price"))
                            if order.get("cumulative_quantity"):
                                cumulative_quantity = float(order.get("cumulative_quantity"))
                            if order.get("cumulative_value"):
                                cumulative_value = float(order.get("cumulative_value"))
                            
                            # Parse timestamps
                            create_time = order.get("create_time", 0)
                            update_time = order.get("update_time", create_time)
                            
                            # Convert Crypto.com timestamp (milliseconds) to ISO format
                            created_at = None
                            updated_at = None
                            if create_time:
                                try:
                                    # Crypto.com timestamps are in milliseconds
                                    if create_time > 1e12:  # milliseconds
                                        created_at = datetime.fromtimestamp(create_time / 1000, tz=timezone.utc).isoformat()
                                    else:  # seconds
                                        created_at = datetime.fromtimestamp(create_time, tz=timezone.utc).isoformat()
                                except (ValueError, OSError):
                                    created_at = None
                            
                            if update_time:
                                try:
                                    if update_time > 1e12:  # milliseconds
                                        updated_at = datetime.fromtimestamp(update_time / 1000, tz=timezone.utc).isoformat()
                                    else:  # seconds
                                        updated_at = datetime.fromtimestamp(update_time, tz=timezone.utc).isoformat()
                                except (ValueError, OSError):
                                    updated_at = None
                            
                            # Map Crypto.com status to our status enum
                            status_mapping = {
                                "ACTIVE": "ACTIVE",
                                "OPEN": "ACTIVE",
                                "PENDING": "ACTIVE",
                                "PARTIALLY_FILLED": "PARTIALLY_FILLED",
                                "FILLED": "FILLED",
                                "CANCELLED": "CANCELLED",
                                "REJECTED": "REJECTED"
                            }
                            mapped_status = status_mapping.get(status, status)
                            
                            open_orders_data.append({
                                "exchange_order_id": order_id,
                                "symbol": instrument_name,
                                "side": side,
                                "order_type": order_type,
                                "status": mapped_status,
                                "price": price if price > 0 else None,
                                "quantity": quantity if quantity > 0 else None,
                                "cumulative_quantity": cumulative_quantity if cumulative_quantity > 0 else None,
                                "cumulative_value": cumulative_value if cumulative_value > 0 else None,
                                "avg_price": avg_price if avg_price > 0 else None,
                                "order_value": order_value if order_value > 0 else None,
                                "created_at": created_at,
                                "updated_at": updated_at
                            })
                        except Exception as e:
                            log.warning(f"Error parsing order {order.get('order_id', 'unknown')}: {e}")
                            continue
                    
                    log.info(f"Retrieved {len(open_orders_data)} open orders directly from Crypto.com API")
                else:
                    log.warning("No orders data in Crypto.com response")
            except Exception as e:
                log.warning(f"Error fetching open orders from Crypto.com API: {e}")
        
        # Convert balances to portfolio assets format for frontend
        portfolio_assets = []
        for bal in balance_data:
            portfolio_assets.append({
                "coin": bal.get("asset", ""),
                "balance": bal.get("balance", 0),
                "available_qty": bal.get("free", bal.get("balance", 0)),
                "reserved_qty": bal.get("locked", 0),
                "value_usd": bal.get("usd_value", 0),
                "pct_portfolio": (bal.get("usd_value", 0) / total_usd_value * 100) if total_usd_value > 0 else 0
            })
        
        # TEMPORARILY DISABLED: Get last sync time to prevent blocking
        # last_sync = exchange_sync_service.last_sync
        # last_sync_str = last_sync.isoformat() if last_sync else None
        last_sync_str = None
        log.debug("Last sync check disabled to prevent timeout")
        
        elapsed_time = time_module.time() - start_time
        log.info(f"‚úÖ Dashboard state fetched in {elapsed_time:.2f}s: {len(balance_data)} balances, {len(fast_signals_data)} fast signals, {len(slow_signals_data)} slow signals, {len(open_orders_data)} open orders")
        
        if elapsed_time > 5.0:
            log.warning(f"‚ö†Ô∏è Dashboard state fetch took {elapsed_time:.2f}s - this is slow! Should be < 1 second")
        
        return {
            "source": "portfolio_cache" if balance_data else "crypto.com",
            "total_usd_value": total_usd_value,
            "balances": balance_data,
            "fast_signals": fast_signals_data,
            "slow_signals": slow_signals_data,
            "open_orders": open_orders_data,
            "last_sync": last_sync_str,
            "portfolio_last_updated": portfolio_last_updated_iso,
            "portfolio": {
                "assets": portfolio_assets,
                "total_value_usd": total_usd_value,
                "exchange": "Crypto.com Exchange"
            },
            "bot_status": {
                "is_running": bot_is_running,
                "status": bot_status,
                "reason": bot_reason
            },
            "partial": partial_response,
            "errors": error_labels
        }
        
    except Exception as e:
        log.error(f"Error getting dashboard state: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Error getting dashboard state: {str(e)}")
